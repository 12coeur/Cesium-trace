<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Visualisation de traces CesiumJS</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.122/Cesium.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.122/Widgets/widgets.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.min.js"></script>
  <style>
    html, body, #map { width:100%; height:100%; margin:0; padding:0; }
    #controls {
      position:absolute;
      top:10px; left:10px;
      background:rgba(0,0,0,0.6);
      padding:8px;
      border-radius:4px;
      z-index:10;
      color:white;
      font-family:sans-serif;
      font-size:14px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <input type="file" id="fileInput" accept=".gpx,.kml,.igc">
    <div id="info" style="margin-top:5px; font-size:12px; color:#ccc;">Choisissez une trace</div>
  </div>

  <div id="map"></div>

  <script>
    // === Initialisation Cesium avec OpenStreetMap ===
    Cesium.Ion.defaultAccessToken = 'YOUR_ION_ACCESS_TOKEN'; // Optionnel si vous utilisez le terrain Cesium

    const viewer = new Cesium.Viewer("map", {
      imageryProvider: new Cesium.UrlTemplateImageryProvider({
        url: "https://tile.openstreetmap.org/{z}/{x}/{y}.png"
      }),
      baseLayerPicker: false,
      timeline: false,
      animation: false
    });

    function clearEntities() {
      viewer.entities.removeAll();
    }

    // === Affichage d'une trace ===
    function showTrace(coords, name) {
      if (coords.length < 2) return;

      const positions = Cesium.Cartesian3.fromDegreesArrayHeights(coords.flat());
      viewer.entities.add({
        name,
        polyline: {
          positions,
          width: 3,
          material: Cesium.Color.YELLOW.withAlpha(0.9)
        }
      });

      const start = coords[0];
      const end = coords[coords.length - 1];
      viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(start[0], start[1], start[2]),
        point: { pixelSize: 10, color: Cesium.Color.GREEN },
        label: { text: `Départ: ${Math.round(start[2])}m`, font: "14px sans-serif", fillColor: Cesium.Color.WHITE }
      });
      viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(end[0], end[1], end[2]),
        point: { pixelSize: 10, color: Cesium.Color.RED },
        label: { text: `Arrivée: ${Math.round(end[2])}m`, font: "14px sans-serif", fillColor: Cesium.Color.WHITE }
      });

      viewer.zoomTo(viewer.entities);
    }

    // === Parsing simple IGC ===
    function parseIGC(content) {
      const lines = content.split("\n");
      const coords = [];
      lines.forEach(line => {
        if (line.startsWith("B") && line.length >= 35) {
          const latStr = line.substring(7, 15);
          const lonStr = line.substring(15, 24);
          const altStr = line.substring(30, 35);

          const latDeg = parseInt(latStr.substring(0, 2), 10);
          const latMin = parseFloat(latStr.substring(2, 7)) / 1000;
          const latDir = latStr[7];
          let lat = latDeg + latMin / 60;
          if (latDir === "S") lat = -lat;

          const lonDeg = parseInt(lonStr.substring(0, 3), 10);
          const lonMin = parseFloat(lonStr.substring(3, 8)) / 1000;
          const lonDir = lonStr[8];
          let lon = lonDeg + lonMin / 60;
          if (lonDir === "W") lon = -lon;

          const alt = parseInt(altStr, 10);
          if (!isNaN(lat) && !isNaN(lon) && !isNaN(alt)) {
            coords.push([lon, lat, alt]);
          }
        }
      });
      return coords;
    }

    // === Parsing GPX ===
    function parseGPX(content) {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(content, "text/xml");
      const trackPoints = xmlDoc.getElementsByTagName("trkpt");
      const coords = [];
      
      for (let i = 0; i < trackPoints.length; i++) {
        const pt = trackPoints[i];
        const lat = parseFloat(pt.getAttribute("lat"));
        const lon = parseFloat(pt.getAttribute("lon"));
        const ele = parseFloat(pt.getElementsByTagName("ele")[0]?.textContent || 0);
        coords.push([lon, lat, ele]);
      }
      return coords;
    }

    // === Parsing KML ===
    function parseKML(content) {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(content, "text/xml");
      const coordinates = xmlDoc.getElementsByTagName("coordinates");
      const coords = [];
      
      if (coordinates.length > 0) {
        const coordText = coordinates[0].textContent.trim();
        const points = coordText.split(/\s+/);
        
        points.forEach(point => {
          const [lon, lat, alt] = point.split(',').map(Number);
          if (!isNaN(lon) && !isNaN(lat)) {
            coords.push([lon, lat, alt || 0]);
          }
        });
      }
      return coords;
    }

    // === Gestionnaire de fichier ===
    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        const content = e.target.result;
        let coords = [];
        let name = file.name;
        
        clearEntities();
        
        if (file.name.endsWith('.igc')) {
          coords = parseIGC(content);
        } else if (file.name.endsWith('.gpx')) {
          coords = parseGPX(content);
        } else if (file.name.endsWith('.kml')) {
          coords = parseKML(content);
        }
        
        if (coords.length > 0) {
          showTrace(coords, name);
          document.getElementById('info').textContent = `${name} - ${coords.length} points`;
        } else {
          document.getElementById('info').textContent = 'Aucune trace valide trouvée';
        }
      };
      reader.readAsText(file);
    });
  </script>
</body>
</html>
